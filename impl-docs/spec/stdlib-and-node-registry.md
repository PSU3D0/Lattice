Status: Draft
Purpose: spec
Owner: Core
Last reviewed: 2026-01-29

# Standard Library and Node Registry (0.1.x)

This document defines how standard library (stdlib) nodes are linked, registered, and validated in
latticeflow. The goal is a **compile-time linked** node surface with deterministic validation and
minimal runtime discovery.

## Goals

- Compile-time linkage for stdlib nodes (missing nodes are build errors).
- Explicit registration into a `NodeRegistry` to enable dead-code elimination.
- Stable node identifiers (`identifier`) for Flow IR portability.
- Allow hosts to gate stdlib nodes based on required capabilities and durability services.

## Non-goals

- Dynamic plugin discovery at runtime (out of scope for stdlib).
- Flow IR containing executable logic or secrets.

## Registry Model

### NodeRegistry

`NodeRegistry` holds node handlers keyed by `identifier`.

- Nodes are registered explicitly (no auto-discovery).
- Registration helpers are generated by `#[node]` (see below).
- The registry is a compile-time surface; missing registrations are compile errors when using
  generated `*_register()` functions.

### NodeResolver

`NodeResolver` is the abstraction boundary for execution:

- Local registry (`NodeRegistry`)
- Plugin resolver (optional, see connector model)
- Remote resolver (future)

Stdlib nodes **must** be resolvable via the local registry to retain compile-time guarantees.

## `#[node]` Macro Outputs

Each stdlib node uses `#[node]` to generate:

- `<fn_name>_node_spec()` — a `NodeSpec` with schemas, effects, determinism, and metadata.
- `<fn_name>_register(registry: &mut NodeRegistry)` — registers handler by identifier.

This ensures:

- Node identifiers are stable and known at compile time.
- Input/output schemas are derived from Rust types.
- Effect/determinism hints are emitted for validation.
- Durability profile (`checkpointable`, `replayable`, `halts`) is emitted for checkpoint validation.

## Flow Bundles and Allowlists

`workflow_bundle!` produces a `FlowBundle` that includes:

- `validated_ir`
- `resolver` (backed by `NodeRegistry`)
- `node_contracts` allowlist (identifiers present in the registry)

Hosts MUST reject Flow IR whose identifiers are not in `node_contracts`.

## Standard Library Packaging

Stdlib nodes should live in a dedicated crate (e.g., `latticeflow-stdlib`) with feature-gated modules.
Recommended layout:

```
crates/stdlib/
  src/
    lib.rs
    timer.rs
    callback.rs
    workspace.rs
    transform/
```

Example feature gating:

```toml
[dependencies]
latticeflow-stdlib = { version = "0.1", features = ["timer", "hitl", "workspace"] }
```

Only explicitly referenced modules are linked, enabling dead-code elimination.

## Subflows as Nodes

Subflows are compiled into the same registry surface via a generated wrapper node. The wrapper:
- Emits `NodeKind::Subflow` in the IR.
- Uses the SubflowDescriptor to populate `effects`, `determinism`, `effect_hints`, and `durability`.
- Registers a handler that executes the referenced subflow bundle in-process.

This keeps subflows compile-linked while preserving the node-based execution model.

## Host Gating and Durability Requirements

Stdlib nodes may require host durability services (e.g., timer/HITL nodes). Nodes declare these
requirements in their metadata; the validator enforces that the host provides them.

See:
- `impl-docs/spec/checkpointing-and-durability.md` (durability services)
- `impl-docs/spec/capabilities-and-binding.md` (durability binding rules)

## Scheduler Selection

Nodes such as `std.timer.wait` optionally accept `scheduler` in their input schema. Scheduler names are
host-configured aliases (not Flow IR). If a flow specifies a scheduler alias that the host does not
provide, validation fails.

## Guidance

- Prefer stdlib nodes for portable, deterministic behavior.
- Avoid runtime discovery for stdlib nodes; keep resolution compile-time.
- Use optional plugin/extension nodes only when explicitly desired and signed off by host policy.
