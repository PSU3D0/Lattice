Status: Draft
Purpose: spec
Owner: Core
Last reviewed: 2026-01-29

# Standard Library and Node Registry (0.1.x)

This document defines how standard library (stdlib) nodes are linked, registered, and validated in
latticeflow. The goal is a **compile-time linked** node surface with deterministic validation and
minimal runtime discovery.

## Goals

- Compile-time linkage for stdlib nodes (missing nodes are build errors).
- Explicit registration into a `NodeRegistry` to enable dead-code elimination.
- Stable node identifiers (`identifier`) for Flow IR portability.
- Allow hosts to gate stdlib nodes based on required capabilities and durability services.

## Non-goals

- Dynamic plugin discovery at runtime (out of scope for stdlib).
- Flow IR containing executable logic or secrets.

## Registry Model

### NodeRegistry

`NodeRegistry` holds node handlers keyed by `identifier`.

- Nodes are registered explicitly (no auto-discovery).
- Registration helpers are generated by `#[def_node]` (see below).
- The registry is a compile-time surface; missing registrations are compile errors when using
  generated `*_register()` functions.

### NodeResolver

`NodeResolver` is the abstraction boundary for execution:

- Local registry (`NodeRegistry`)
- Plugin resolver (optional, see connector model)
- Remote resolver (future)

Stdlib nodes **must** be resolvable via the local registry to retain compile-time guarantees.

## `#[def_node]` Macro Outputs

Each stdlib node uses `#[def_node]` to generate:

- `<fn_name>_node_spec()` — a `NodeSpec` with schemas, effects, determinism, and metadata.
- `<fn_name>_register(registry: &mut NodeRegistry)` — registers handler by identifier.

This ensures:

- Node identifiers are stable and known at compile time.
- Input/output schemas are derived from Rust types.
- Effect/determinism hints are emitted for validation.
- Durability profile (`checkpointable`, `replayable`, `halts`) is emitted for checkpoint validation.

## Flow Bundles and Allowlists

`flow!` produces a `FlowBundle` that includes:

- `validated_ir`
- `resolver` (backed by `NodeRegistry`)
- `node_contracts` allowlist (identifiers present in the registry)

When authoring, `node!(...)` is the canonical helper for binding generated node specs into a flow.

Hosts MUST reject Flow IR whose identifiers are not in `node_contracts`.

### Flow Entrypoint Constants

`flow!` emits typed entrypoint constants scoped to the module that defines the flow. For flows with a
single entrypoint, a root alias may be exposed for convenience in addition to the module-scoped const.

## Entrypoints and Triggers

- Triggers are `NodeKind::Trigger` nodes that represent ingress boundaries.
- Entrypoints are explicit bundle metadata binding `trigger_alias` + `capture_alias`.
- Entrypoints may include `route_aliases` for UX, but hosts derive canonical routes deterministically.
  `route_aliases` are not authoritative and do not replace canonical routing.
- `#[def_node(trigger)]` is the shorthand for defining trigger nodes.

## Standard Library Packaging

Stdlib nodes should live in a dedicated crate (e.g., `latticeflow-stdlib`) with feature-gated modules.
Recommended layout:

```
crates/stdlib/
  src/
    lib.rs
    timer.rs
    callback.rs
    workspace.rs
    transform/
```

Example feature gating:

```toml
[dependencies]
latticeflow-stdlib = { version = "0.1", features = ["timer", "hitl", "workspace"] }
```

Only explicitly referenced modules are linked, enabling dead-code elimination.

## Stdlib vs Connectors vs Contrib

Stdlib is intentionally small and foundational. It should only include host-portable primitives and
core control/utility nodes. Large connector surfaces (Google, Slack, etc.) should live in dedicated
connector crates, not in stdlib.

Recommended crate tiers:
- **Core stdlib**: `crates/stdlib/` (timer/callback waits, workspace nodes, basic transforms/utilities).
- **Connector crates**: `crates/connectors/<vendor>/` (first-party curated connectors).
- **Contrib**: `crates/contrib/<vendor>/` (experimental/community connectors).
- **Subflow bundles**: `crates/flows/` or `crates/subflows/` (stdlib of flows).

This keeps the stdlib stable while allowing the connector ecosystem to scale without bloating the core.

## Subflows as Nodes

Subflows are compiled into the same registry surface via a generated wrapper node. The wrapper:
- Emits `NodeKind::Subflow` in the IR.
- Uses the SubflowDescriptor to populate `effects`, `determinism`, `effect_hints`, and `durability`.
- Registers a handler that executes the referenced subflow bundle in-process.

This keeps subflows compile-linked while preserving the node-based execution model.

## Host Gating and Durability Requirements

Stdlib nodes may require host durability services (e.g., timer/HITL nodes). Nodes declare these
requirements in their metadata; the validator enforces that the host provides them.

See:
- `impl-docs/spec/checkpointing-and-durability.md` (durability services)
- `impl-docs/spec/capabilities-and-binding.md` (durability binding rules)

## Scheduler Selection

Nodes such as `std.timer.wait` optionally accept `scheduler` in their input schema. Scheduler names are
host-configured aliases (not Flow IR). If a flow specifies a scheduler alias that the host does not
provide, validation fails.

## Guidance

- Prefer stdlib nodes for portable, deterministic behavior.
- Avoid runtime discovery for stdlib nodes; keep resolution compile-time.
- Use optional plugin/extension nodes only when explicitly desired and signed off by host policy.
